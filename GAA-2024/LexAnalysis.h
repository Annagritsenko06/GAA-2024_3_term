#pragma once
#include "LT.h"
#include "In.h"
#include "Log.h"
#include "FST.h"

// проверка входных токенов
#define TYPE_NUMBER		"bint"
#define TYPE_STRING		"string"
#define TYPE_SMBL		"osymb"
#define TYPE_TBOOL      "tbool"
#define TYPE_TRUE       "true"
#define TYPE_FALSE      "false"
#define STRCOPY			"strcopy"
#define MAIN			"main"
#define LENGHT			"mystrlen"


#define ISTYPE(str) ( !strcmp(str, TYPE_NUMBER) || !strcmp(str, TYPE_STRING) ||!strcmp(str, TYPE_SMBL) || !strcmp(str, TYPE_TBOOL))

namespace Lexer
{
	struct LEX
	{
		LT::LexTable lextable;
		IT::IdTable	idtable;
		LEX() {}
	};
	struct Graph
	{
		char lexema;
		FST::FST graph;
	};


	IT::Entry* getEntry		// формирует и возвращает строку ТИ
	(
		Lexer::LEX& tables,				// ТЛ + ТИ
		char lex,						// лексема
		char* id,						// идентификатор
		char* idtype,					// предыдущая (тип)
		bool isParam,					// признак параметра функции
		bool isFunc,					// признак функции
		Log::LOG log,					// протокол
		int line,						// строка в исходном тексте
		bool& rc_err					// флаг ошибки(по ссылке)
	);

	struct ERROR_S			// тип исключения для throw ERROR_THROW | ERROR_THROW_IN
	{
		int id;
		char message[ERROR_MAXSIZE_MESSAGE];	// сообщение			
		struct
		{
			short line = -1;			//номер строки (0, 1, 2, ...)
			short col = -1;				//номер позиции в строке(0, 1, 2, ...)
		} position;
	};
	bool analyze(LEX& tables, In::IN& in, Log::LOG& log, Parm::PARM& parm);
	int	getIndexInLT(LT::LexTable& lextable, int itTableIndex);			// индекс первой встречи в таблице лексем
};

